<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Better Than Human — Flyxion</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: #0a0a0a;
      color: #e6e6e6;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    canvas {
      width: 320px;
      height: 320px;
      border-radius: 50%;
      background: radial-gradient(circle at center, #111 0%, #000 100%);
      box-shadow: 0 0 20px #fff1;
      transition: transform 0.05s;
    }
    canvas:active {
      transform: scale(0.98);
    }
    .controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    button {
      background: #111;
      border: 1px solid #333;
      color: #eee;
      font-weight: bold;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      text-transform: uppercase;
    }
    button:hover { background: #181818; }
    .timer {
      font-size: 1.2em;
      letter-spacing: 1px;
      min-width: 80px;
      text-align: center;
      transition: opacity 0.1s, filter 0.1s;
    }
    .glitch-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(90deg, rgba(255,255,255,0.05) 0 2px, transparent 2px 4px);
      opacity: 0;
      transition: opacity 0.1s, filter 0.1s;
      mix-blend-mode: screen;
    }
  </style>
</head>
<body>
  <h2>Better Than Human — Flyxion</h2>
  <p style="opacity:0.6;font-size:0.9em;margin-top:-10px;">Inspired by <i>Machines Like Me</i> by Ian McEwan</p>
  <canvas id="turntable"></canvas>
  <div class="controls">
    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <div class="timer" id="timer">00:00</div>
    <button id="loop">Loop: Off</button>
  </div>
  <div class="glitch-overlay" id="glitch"></div><audio id="audio" src="Better Than Human.mp3" crossorigin="anonymous"></audio>

  <script>
    const audio = document.getElementById('audio');
    const playBtn = document.getElementById('play');
    const pauseBtn = document.getElementById('pause');
    const loopBtn = document.getElementById('loop');
    const timer = document.getElementById('timer');
    const canvas = document.getElementById('turntable');
    const ctx = canvas.getContext('2d');
    const glitch = document.getElementById('glitch');

    let rotation = 0;
    let isDragging = false;
    let lastAngle = 0;
    let pulseAlpha = 0;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = 320 * dpr;
    canvas.height = 320 * dpr;
    ctx.scale(dpr, dpr);

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ctxAudio = new AudioContext();
    const src = ctxAudio.createMediaElementSource(audio);
    const analyser = ctxAudio.createAnalyser();
    analyser.fftSize = 256;
    src.connect(analyser);
    analyser.connect(ctxAudio.destination);

    // Reactive glitch overlay
    const freqData = new Uint8Array(analyser.frequencyBinCount);
    function glitchEffect() {
      analyser.getByteFrequencyData(freqData);
      let bass = 0;
      for (let i = 0; i < 32; i++) bass += freqData[i];
      bass /= 32;
      const brightness = Math.min(1, bass / 180);

      if (brightness > 0.2) {
        glitch.style.opacity = brightness;
        glitch.style.filter = `contrast(${1 + brightness * 1.5}) brightness(${1 + brightness})`;
        glitch.style.background = Math.random() > 0.5
          ? 'repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 3px)'
          : 'repeating-linear-gradient(90deg, rgba(255,255,255,0.06) 0 2px, transparent 2px 4px)';
        // Timer flicker synced to glitch
        timer.style.opacity = 0.7 + Math.random() * 0.3;
        timer.style.filter = `contrast(${1 + brightness}) brightness(${1 + brightness * 0.5})`;
      } else {
        glitch.style.opacity = 0;
        timer.style.opacity = 1;
        timer.style.filter = 'none';
      }
      requestAnimationFrame(glitchEffect);
    }

    function drawTurntable() {
      ctx.clearRect(0, 0, 320, 320);
      ctx.save();
      ctx.translate(160, 160);
      ctx.rotate(rotation);

      ctx.strokeStyle = '#e6e6e6';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, 150, 0, Math.PI * 2);
      ctx.stroke();

      for (let i = 120; i > 20; i -= 5) {
        ctx.strokeStyle = `rgba(255,255,255,${0.01 + i/600})`;
        ctx.beginPath();
        ctx.arc(0, 0, i, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(0, 0, 25, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function animate() {
      rotation += 0.02;
      drawTurntable();
      requestAnimationFrame(animate);
    }

    // Timer countdown display
    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    function updateTimer() {
      if (audio.duration) {
        const remaining = Math.max(0, audio.duration - audio.currentTime);
        timer.textContent = formatTime(remaining);
      }
      requestAnimationFrame(updateTimer);
    }

    // Loop button
    loopBtn.onclick = () => {
      audio.loop = !audio.loop;
      loopBtn.textContent = `Loop: ${audio.loop ? 'On' : 'Off'}`;
    };

    // Turntable rotation drag
    function getAngle(e, rect) {
      const touch = e.touches ? e.touches[0] : e;
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const dx = touch.clientX - cx;
      const dy = touch.clientY - cy;
      return Math.atan2(dy, dx);
    }

    function startDrag(e) {
      isDragging = true;
      const rect = canvas.getBoundingClientRect();
      lastAngle = getAngle(e, rect);
    }

    function moveDrag(e) {
      if (!isDragging) return;
      const rect = canvas.getBoundingClientRect();
      const angle = getAngle(e, rect);
      let delta = angle - lastAngle;
      if (delta > Math.PI) delta -= Math.PI * 2;
      if (delta < -Math.PI) delta += Math.PI * 2;
      rotation += delta;
      lastAngle = angle;
    }

    function endDrag() { isDragging = false; }

    canvas.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
    canvas.addEventListener('touchstart', startDrag, {passive:true});
    window.addEventListener('touchmove', moveDrag, {passive:true});
    window.addEventListener('touchend', endDrag, {passive:true});

    playBtn.onclick = () => { ctxAudio.resume(); audio.play(); glitchEffect(); };
    pauseBtn.onclick = () => audio.pause();

    animate();
    updateTimer();
  </script></body>
</html>
